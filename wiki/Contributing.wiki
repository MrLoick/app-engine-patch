#summary How you can help and how to send patches.
#labels Featured

= Community building =

Spread the word. Write about app-engine-patch on your blog. Feel free to post a link to your article on our [http://groups.google.com/group/app-engine-patch mailing list].

We could also need an article in the [http://code.google.com/appengine/articles/ App Engine articles section].

Actively participate on our [http://groups.google.com/group/app-engine-patch mailing list]. Answer questions and make suggestions.

Take part in hack-a-thons and tell others about app-engine-patch.

Give presentations at conferences.

= Make suggestions =

We want to steadily improve app-engine-patch. Please join our [http://groups.google.com/group/app-engine-patch mailing list] and make suggestions on how to make app-engine-patch easier to use and more powerful.

= Coding =

First please read [GettingTheSource how to get the source].

Subscribe to our [http://groups.google.com/group/app-engine-patch mailing list].

Take a look at the list of [http://code.google.com/p/app-engine-patch/issues/list open issues] or suggest a great new feature yourself! The most useful features would be support for Django's admin interface and the comments app.

= Extending app-engine-patch =

Basically, app-engine-patch is a collection of monkey-patches. We manipulate Django's modules, classes, and functions to be compatible with App Engine. If you want to extend app-engine-patch you should first take a look at these files (in "common/appenginepatch"):

 * manage.py
 * main.py
 * aecmd.py
 * appenginepatcher/patch.py

There are various patching techniques with their own advantages and disadvantages.

== On-demand patching ==

Where possible you should use this method. The idea is that you replace some modules in a package with a modified version, by manipulating the package's `__path__`. At the same time you can import stuff from the original module via `<package>.__original__.<module>`, so you don't have to copy the whole source, but instead only the parts that should be modified.

This is done with a special `patch_package()` function which takes two arguments: the package you want to patch and the name of the subfolder under "appenginepatcher/" that contains the replacement modules. For example, here we replace Django's serializers (see "appenginepatcher/patch.py"):

{{{
# Patch serializers
patch_package('django.core.serializers', 'serializers')
}}}

From now on, when you import `django.core.serializers.json` the `json` module in the "serializers" folder will get loaded instead of the Django version. You could now replace the `PythonDeserializer` variable in that module with this code:

{{{
# Import all functions and classes from original json module
from django.core.serializers.__original__.json import *

# Replace PythonDeserializer
PythonDeserializer = ...
}}}

Now, in this case we have a problem because the original json module uses that variable in one of its functions. Our replacement only works for code that tries to import the json module, but here we need to tell the functions in the json module to use a different variable. This can be done with static monkey-patching.


== Static monkey-patching ==

This method works like this: You simply import a module or class and modify it directly by assigning values to variables. Going back to our json serializer example, here's the code:

{{{
# Import all functions and classes from original json module
from django.core.serializers.__original__.json import *
# Import json module itself, so we can statically monkey-patch it
from django.core.serializers.__original__ import json

# Replace PythonDeserializer
PythonDeserializer = ...

# Modify the original json module, so it uses the changed variable, too.
json.PythonDeserializer = PythonDeserializer
}}}


== Manipulating sys.modules ==

Sometimes you have to unload or replace a module that has already been loaded. All loaded modules are cached in `sys.modules`. For example, here we replace the default `imp` module with a patched version:

{{{
import sys
from appenginepatcher import imp
sys.modules['imp'] = imp
}}}


== Adding custom patches to your project ==

If you want to add a few custom patches you have to write your own main.py handler. You could copy the original main.py and modify the code, but then you'd have to track changes in app-engine-patch and update your main.py manually. There's an easier alternative. Write your own main.py and import everything from the original main.py:

{{{
from common.appenginepatch.main import *

# Do your own patching here
# ...

if __name__ == '__main__':
    main()
}}}


= Sending patches =

The easiest way to create a patch is by committing it into your local repository with `hg ci` and exporting it with `hg bundle mypatch.bundle`. Just create a new issue describing your improvement and attach the bundle. You can alternatively use the [http://www.selenic.com/mercurial/wiki/index.cgi/MqExtension patch queues extension] and send a normal diff, but that's more complicated and should be used if you need powerful patch management.

Just send the patch to our [http://groups.google.com/group/app-engine-patch mailing list] or create a new issue and attach your patch.

= Donating =

Alternatively, we'd be very grateful for a little [Donate donation]. :)