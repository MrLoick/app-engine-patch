#labels Featured
= appenginepatch =

 * [GettingStarted Getting started]
 * [Profiling Using the profiler]
 * [ZipPackages Integrating zipped packages]


= ragendja =


== ragendja.auth.decorators ==

The `@staff_only` view decorator only renders the view if `request.user.is_staff` is `True`. Otherwise it renders a `no_access.html` template (which you have to create yourself).

== ragendja.auth.models ==

This module provides base models for customizing your User class:
 * `UserTraits` has only a few basic user fields (see the source for more details), but no `username`.
 * `EmailUser` also adds an `email` field, `email_user()`, and an `is_banned` field, but no `username`.
 * `User` is the same as Django's `User` class; it includes a `username`.
The password field is not required because with the new authentication methods
like OpenID and InfoCards you might not need it.

Instead of using `AUTH_PROFILE_MODULE` you can derive your profile from one of the user classes in `ragendja.auth.models`. Then, specify your profile module via `AUTH_USER_MODULE` in `settings.py`. This should only be the module name (e.g., `'myapp.models'`) and the class MUST be named `User`. The result is that whenever you import `User` from `django.contrib.auth.models` you automatically get your custom user class and thus don't need to use the ugly get_profile() function to switch around between two models. Note that you can't import `django.contrib.auth` from the module that defines your `User` class. If you don't specify a user class then ragendja's `User` is used by default.

*Example:*
{{{
# myuser/models.py:
from google.appengine.ext import db
from ragendja.auth.models import EmailUser

class User(EmailUser):
    first_name = db.StringProperty()
    last_name = db.StringProperty()

# settings.py:
AUTH_USER_MODULE = 'myuser.models'
}}}

With the above code `from django.contrib.auth.models import User` becomes the same as `from myuser.models import User`. In order to maximize code reuse you should always import the Django model in your apps (`from django.contrib.auth.models import User`), so your code is independent of the `User` class of your particular project.

== ragendja.dbutils ==

=== @transaction ===

`@transaction` is a simple wrapper for db.run_in_transaction. It allows for
writing more correct code because the caller doesn't have to care about
calling db.run_in_transaction, manually (he has to know that the function runs
in a transaction, though).

*Example:*
Instead of writing `db.run_in_transaction` all the time:
{{{
def do_something(...):
    ...

def view1(request, ...):
    ...
    db.run_in_transaction(do_something, ...)
    ...

def view2(request, ...):
    ...
    db.run_in_transaction(do_something, ...)
    ...

}}}
You can just write this:
{{{
@transaction
def do_something(...):
    ...

def view1(request, ...):
    ...
    do_something(...)
    ...

def view2(request, ...):
    ...
    do_something(...)
    ...
}}}

=== db_create(model, ...attrs...) ===

This function safely creates a new entity with a random key_name.

*Example:*
{{{
item = db_create(MyModel, title='hey', index=4)
# item.key().name() could be "a1K6AMAo55BepDcx"
}}}

=== db_add(model, key_name, ...attrs...) ===

This function adds an entity to the datastore if it doesn't exist. Otherwise it returns None. Note that this function automatically runs in a transaction.

*Example:*
{{{
item = db_add(MyModel, 'some_key_name', title='hey', index=4)
if not item:
    # entity with that key_name already exists!
else:
    # we've added a new entity
}}}

=== get_object_or_404(model, filters or key or key_name or id) ===

This is similar to Django's shortcut, but allows for using a `key_name` or `id` keyword argument or a key object/string to retrieve a specific object. Alternatively, you can specify a list of filter rules:
{{{
item = get_object_or_404(MyModel, key)
item = get_object_or_404(MyModel, key_name='somekey')
item = get_object_or_404(MyModel, id=5)
item = get_object_or_404(MyModel, 'title =', 'ABC', 'counter >', 5)
}}}

=== get_list_or_404(model, ...filters...) ===

The `get_list_or_404()` shortcut only expects a list of filter rules and works similar to Django's version.

=== generate_key_name(...parts...) ===

This generates a `key_name` from the given strings. It automatically prefixes the key with a 'k', so it's guaranteed to be valid and separates all parts with a '/' (while escaping the separator in each part, so it's a non-ambiguous transformation):
{{{
>>> generate_key_name('abc', 'def')
'kabc/def'
}}}

=== to_json_data(entity_or_list, property_or_properties) ===
*List feature only available in repository*

Converts a models into dicts for use with JSONResponse.

You can either pass a single model instance and get a single dict or a list of models and get a list of dicts.

For security reasons only the properties in the property_list will get added. If the value of the property has a json_data function its result will be added, instead.

=== KeyReferenceProperty ===

Creates a cached accessor for an object referenced by a string property that stores a `str(key)` or `key_name`. This is useful if you need to work with the key of a referenced object, but mustn't `get()` it from the datastore. It takes the name of the property, the model to `get()`, and a boolean that specifies whether the string property contains a key or a key name:
{{{
class File(db.Model):
    creator_key_name = db.StringProperty(required=True)
    creator = KeyReferenceProperty('creator_key_name', User, use_key_name=True)
}}}

=== prefetch_references(entity_list, property_or_properties) ===
*Only available in repository*

Dereferences the given (Key)ReferenceProperty fields of a list of objects in as few get() calls as possible.


== ragendja.middleware ==

=== LoginRequiredMiddleware ===

This saves you from typing `@login_required` all the time.

*Example:*
{{{
MIDDLEWARE_CLASSES = (
    ...,
    'ragendja.middleware.LoginRequiredMiddleware',
)
LOGIN_REQUIRED_PREFIXES = (
    '/some/path/',
    '/other/path/',
)
NO_LOGIN_REQUIRED_PREFIXES = (
    '/some/path/without_login/',
)
}}}
With this you require login for all paths that start with `'/other/path'` or `'/some/path/'` except for `'/some/path/without_login/'`. IOW, `NO_LOGIN_REQUIRED_PREFIXES` overrides `LOGIN_REQUIRED_PREFIXES`.


== ragendja.template ==

=== app_prefixed_loader ===

The template loader `app_prefixed_loader` allows for DRY separation of app
templates. For example, you can render the template `<app>/templates/bla.html` by loading
`render_to_response(request, '<app>/bla.html')`. There's no need for prefixing app templates (`'<app>_bla.html'`) or creating subfolders (`'<app>/templates/<app>/bla.html'`). For maximum compatibility you should use the following order in your `settings.py`:
{{{
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.load_template_source',
    'ragendja.template.app_prefixed_loader',
    'django.template.loaders.app_directories.load_template_source',
)
}}}

=== Global template tags ===

You can add global template tags by specifying the list of modules in a `GLOBALTAGS` variable in `settings.py` like in this example:
{{{
GLOBALTAGS = (
    'ragendja.templateutils',
    'myapp.templatetags.sometag',
)
}}}

=== render_to_response(request, template, data, mimetype) ===

This is an improved `render_to_response()` that uses `RequestContext` in order to support context processors. There's also a `render_to_string()` function that supports context processors. The `data` and `mimetype` arguments are optional.

=== JSONResponse(data) ===

This converts a Python object (`data`) into a JSON string and creates an HttpResponse with the correct MIME type.


== ragendja.templatetags.ragendjatags ==

=== register ===

This is a context_processor that adds an `encodejs` filter that converts Python to a JSON string.


== ragendja.testutils ==

=== ModelTestCase ===

This provides an easy way to validate the contents of the DB. You have to specify the model to validate against with the `model` attribute. From then on you can call `validate_state()` to check if a certain function modifies the DB contents correctly:

*Example:* The following validates that the table contains exactly two rows and that their 'a', 'b', and 'c' attributes are 1, 2, 3 for one row and 11, 12, 13 for the other row. The order of the rows doesn't matter.
{{{
class MyTestCase(ModelTestCase):
    model = MyModel

    def test_valid_function():
        # Do something that changes the DB
        change_something()
        # Now check if that function worked correctly
        self.validate_state(
            ('a', 'b', 'c'),
            (1, 2, 3),
            (11, 12, 13),
        )
}}}

= appenginepatcher =

You can find out whether you're running on the production server:
{{{
from appenginepatcher import on_production_server
if on_production_server:
    # we're on the production server...
else:
    # dev_appserver...
}}}