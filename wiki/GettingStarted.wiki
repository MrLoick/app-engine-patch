#summary Getting started with app-engine-patch and what's different.
#labels Featured

= Introduction =

We provide a sample project in the [http://code.google.com/p/app-engine-patch/downloads/list downloads] section that comes with app-engine-patch and a zipped Django package pre-installed.

Most manage.py commands just work (runserver, test, flush, ...), so you should be in a familiar environment. If you want to upload your website to Google you can run "manage.py update" (don't forget to set your appid in app.yaml). There's also support for removing unused indexes via "manage.py vacuum_indexes".

Before continuing please make sure that you've read the:
 * [http://docs.djangoproject.com/en/dev/ Django documentation]
 * [http://code.google.com/appengine/docs/ App Engine documentation]


= Updating =

If you want to update an existing project please download the most recent sample project, then replace your "appenginepatch" and "django-locale" folders and the "zip-packages/django.zip" file with the versions contained in the sample project. Also please read the [ReleaseNotes release notes], so you don't miss important changes.


= Differences compared to plain Django =

Most of your Django code should just work. Still, you should know about the following details.

== settings.py ==

The default (database) auth and session backends automatically get replaced with versions that use the App Engine datastore, so you don't need to change any of your settings. Alternatively, you can specify your own backends as long as they don't depend on unsupported APIs (unsupported: Django models, SQL, sockets).

Email server settings are only used in the development environment. On the production server you automatically use Google's mail backend. Note that currently Google's SDK doesn't work with gmail accounts and other servers that require TLS. This is a bug in App Engine and we've already filed a bug report.

At least the following apps are not supported because they depend on Django's Model class (though, we might port those apps when we need them for our own websites):
 * `django.contrib.admin`
 * `django.contrib.comments`
 * `django.contrib.contenttypes`
 * `django.contrib.databrowse`
 * `django.contrib.flatpages`
 * `django.contrib.gis`
 * `django.contrib.redirects`
 * `django.contrib.sites`

You can't use the `TransactionMiddleware` due to conceptual differences which make it impossible to implement in App Engine.

== Models ==

We only support [http://code.google.com/appengine/docs/datastore/ App Engine models] (`from google.appengine.ext import db`). Django models don't work. There are quite a few conceptual differences, especially with transactions, unique properties, and queries, so we can't emulate Django in this area.

== User model ==

Since there are no unique properties in App Engine the User model doesn't guarantee uniqueness of the `username`.

You can work around this by manually setting the key_name and using a transaction when creating a User entity, but this means you won't be able to change the `username` afterwards.

Alternatively, you can give up guaranteed uniqueness and check with `filter()` to ensure that the username isn't taken. This might be sufficient.

== Generic views ==

The `object_list`, `create_update`, and `simple` modules are supported. The `date_based` generic views can't be implemented efficiently on App Engine and thus won't be supported.

If a generic view expects an `object_id` parameter you may provide a number to indicate a key_id or a string to indicate a `key_name` or `str(key)`.

The number of search results shown by `object_list` is limited to 301, so you don't have to mess with datastore timeouts or too large requests. Why exactly 301 results? That's because you probably want to say "more than 300 results" on your search results page. ;) If you want to handle more results than that you have to use a more [http://sites.google.com/site/io/building-scalable-web-applications-with-google-app-engine scalable search method].

= Paths =

The default project handler adds "common/appenginepatch" and "common" to sys.path.
This means that you don't have to specify "common.xxx" in your imports.
For example, you can import something from ragendja like this:
`from ragendja.testutils import ModelTestCase`

Never import `from projectname.appname`, but import `from appname` directly. This also has the advantage that your code becomes more reusable.