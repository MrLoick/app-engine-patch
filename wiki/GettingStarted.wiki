#summary Installing and using appenginepatch
#labels Featured

Important: You have to use at least Django 0.97 (trunk).

= Installing appenginepatch =

Use the following project structure:

{{{
project root
  app.yaml
  settings.py
  manage.py    (copy from appenginepatch)
  common
    .google_appengine  (only if you use Linux)
    appenginepatch     (copy the whole main folder)
    django             (your custom Django checkout)
}}}

Don't forget to copy manage.py from the appenginepatch folder into your project root. You can only execute it from your project's root folder.

If you're on Linux you can put the App Engine SDK into a folder
".google_appengine" under "common". Windows and Max OS should work out of the
box as long as you used the standard installation paths.

= Using appenginepatch =

Your app.yaml could look like this:

{{{
application: mycoolapp
version: 1
runtime: python
api_version: 1

handlers:
- url: /media
  static_dir: media

- url: /.*
  script: common/appenginepatch/main.py
}}}

This will use the default main.py handler which should work for most projects.


== IMPORTANT: Paths ==

The default project handler adds "appenginepatch" and "common" to sys.path.
This means that you don't have to specify "common.xxx" in your imports.
For example, you can import something from ragendja directly with:
`from ragendja.testutils import ModelTestCase`

= Porting existing Django applications =

If you've followed the instructions above most of your Django code should just work. Still, you should know about the following details.

== settings.py ==

All you need to do is set `DATABASE_ENGINE = 'appengine'` and remove all other database settings (host, username, password, etc.).

The cache backend configuration is ignored and always set to Google's memcache API.

The default (database) auth and session backends automatically get replaced with versions that use the App Engine datastore, so you don't need to change any of your settings. Alternatively, you can specify your own backends as long as they don't depend on unsupported APIs (unsupported: Django models, SQL, sockets).

Email server settings are only used in the development environment. On the production server you automatically use Google's mail backend. Note that currently Google's SDK doesn't work with gmail accounts and other servers that require TLS. This is not our mistake and we've already filed a bug report.

== User model ==

Due to the way the datastore works there is a little problem with properties that must be unique. Our default `User` class does provide a `username` property, but you have to additionally assign a `key_name` and create the user within a transaction that calls `get()` to ensure that the username isn't already taken and only then add the user to the datastore (within the same transaction, of course). This has the problem that username changes become very complicated because an entity's key can't be changed.

Alternatively, you can give up guaranteed uniqueness and mess around with `filter()` to ensure that the username isn't taken. This might be sufficient for most applications.

== Models ==

We only support [http://code.google.com/appengine/docs/datastore/ App Engine models] (`google.appengine.ext.db.Model`). You have to port all Django Model-based code. There are quite a few conceptual differences, especially with transactions and queries. Model definitions look similar, though. Read the [http://code.google.com/appengine/docs/datastore/ datastore documentation] for more information.